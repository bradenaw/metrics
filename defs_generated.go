package metrics

import "reflect"

// generated by `go run ./gen_defs > defs_generated.go && gofmt -w defs_generated.go`

// CounterDef1 is the definition of a counter metric with 1 tag(s).
type CounterDef1[V0 TagValue] struct {
	name   string
	prefix []string
	keys   [1]string

	ok bool
}

// NewCounterDef1 defines a counter metric with 1 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewCounterDef1[V0 TagValue](
	name string,
	description string,
	unit Unit,
	keys [1]string,

) CounterDef1[V0] {

	var zero0 V0

	ok := registerDef(
		CounterType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),
		},
	)
	return CounterDef1[V0]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a CounterDef that has all of the given tag values bound. It can be passed to
// Metrics.Counter() to produce a metric to log data to.
func (d CounterDef1[V0]) Values(v0 V0) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),
		}),

		ok: d.ok,
	}
}

// CounterDef2 is the definition of a counter metric with 2 tag(s).
type CounterDef2[V0 TagValue, V1 TagValue] struct {
	name   string
	prefix []string
	keys   [2]string

	ok bool
}

// NewCounterDef2 defines a counter metric with 2 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewCounterDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,

) CounterDef2[V0, V1] {

	var zero0 V0

	var zero1 V1

	ok := registerDef(
		CounterType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),
		},
	)
	return CounterDef2[V0, V1]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a CounterDef that has all of the given tag values bound. It can be passed to
// Metrics.Counter() to produce a metric to log data to.
func (d CounterDef2[V0, V1]) Values(v0 V0, v1 V1) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		}),

		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a CounterDef1 that
// can be used to set the rest.
func (d CounterDef2[V0, V1]) Prefix1(v0 V0) CounterDef1[V1] {
	return CounterDef1[V1]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[1]string)(d.keys[1:])),

		ok: d.ok,
	}
}

// CounterDef3 is the definition of a counter metric with 3 tag(s).
type CounterDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name   string
	prefix []string
	keys   [3]string

	ok bool
}

// NewCounterDef3 defines a counter metric with 3 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewCounterDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,

) CounterDef3[V0, V1, V2] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	ok := registerDef(
		CounterType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),
		},
	)
	return CounterDef3[V0, V1, V2]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a CounterDef that has all of the given tag values bound. It can be passed to
// Metrics.Counter() to produce a metric to log data to.
func (d CounterDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		}),

		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a CounterDef2 that
// can be used to set the rest.
func (d CounterDef3[V0, V1, V2]) Prefix1(v0 V0) CounterDef2[V1, V2] {
	return CounterDef2[V1, V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[2]string)(d.keys[1:])),

		ok: d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a CounterDef1 that
// can be used to set the rest.
func (d CounterDef3[V0, V1, V2]) Prefix2(v0 V0, v1 V1) CounterDef1[V2] {
	return CounterDef1[V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[1]string)(d.keys[2:])),

		ok: d.ok,
	}
}

// CounterDef4 is the definition of a counter metric with 4 tag(s).
type CounterDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name   string
	prefix []string
	keys   [4]string

	ok bool
}

// NewCounterDef4 defines a counter metric with 4 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewCounterDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,

) CounterDef4[V0, V1, V2, V3] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	var zero3 V3

	ok := registerDef(
		CounterType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),

			reflect.TypeOf(zero3),
		},
	)
	return CounterDef4[V0, V1, V2, V3]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a CounterDef that has all of the given tag values bound. It can be passed to
// Metrics.Counter() to produce a metric to log data to.
func (d CounterDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		}),

		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a CounterDef3 that
// can be used to set the rest.
func (d CounterDef4[V0, V1, V2, V3]) Prefix1(v0 V0) CounterDef3[V1, V2, V3] {
	return CounterDef3[V1, V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[3]string)(d.keys[1:])),

		ok: d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a CounterDef2 that
// can be used to set the rest.
func (d CounterDef4[V0, V1, V2, V3]) Prefix2(v0 V0, v1 V1) CounterDef2[V2, V3] {
	return CounterDef2[V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[2]string)(d.keys[2:])),

		ok: d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a CounterDef1 that
// can be used to set the rest.
func (d CounterDef4[V0, V1, V2, V3]) Prefix3(v0 V0, v1 V1, v2 V2) CounterDef1[V3] {
	return CounterDef1[V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys: *((*[1]string)(d.keys[3:])),

		ok: d.ok,
	}
}

// CounterDef5 is the definition of a counter metric with 5 tag(s).
type CounterDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name   string
	prefix []string
	keys   [5]string

	ok bool
}

// NewCounterDef5 defines a counter metric with 5 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewCounterDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,

) CounterDef5[V0, V1, V2, V3, V4] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	var zero3 V3

	var zero4 V4

	ok := registerDef(
		CounterType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),

			reflect.TypeOf(zero3),

			reflect.TypeOf(zero4),
		},
	)
	return CounterDef5[V0, V1, V2, V3, V4]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a CounterDef that has all of the given tag values bound. It can be passed to
// Metrics.Counter() to produce a metric to log data to.
func (d CounterDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		}),

		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a CounterDef4 that
// can be used to set the rest.
func (d CounterDef5[V0, V1, V2, V3, V4]) Prefix1(v0 V0) CounterDef4[V1, V2, V3, V4] {
	return CounterDef4[V1, V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[4]string)(d.keys[1:])),

		ok: d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a CounterDef3 that
// can be used to set the rest.
func (d CounterDef5[V0, V1, V2, V3, V4]) Prefix2(v0 V0, v1 V1) CounterDef3[V2, V3, V4] {
	return CounterDef3[V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[3]string)(d.keys[2:])),

		ok: d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a CounterDef2 that
// can be used to set the rest.
func (d CounterDef5[V0, V1, V2, V3, V4]) Prefix3(v0 V0, v1 V1, v2 V2) CounterDef2[V3, V4] {
	return CounterDef2[V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys: *((*[2]string)(d.keys[3:])),

		ok: d.ok,
	}
}

// Prefix4 sets the value of the first 4 tags, returning a CounterDef1 that
// can be used to set the rest.
func (d CounterDef5[V0, V1, V2, V3, V4]) Prefix4(v0 V0, v1 V1, v2 V2, v3 V3) CounterDef1[V4] {
	return CounterDef1[V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		keys: *((*[1]string)(d.keys[4:])),

		ok: d.ok,
	}
}

// GaugeDef1 is the definition of a gauge metric with 1 tag(s).
type GaugeDef1[V0 TagValue] struct {
	name   string
	prefix []string
	keys   [1]string

	ok bool
}

// NewGaugeDef1 defines a gauge metric with 1 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewGaugeDef1[V0 TagValue](
	name string,
	description string,
	unit Unit,
	keys [1]string,

) GaugeDef1[V0] {

	var zero0 V0

	ok := registerDef(
		GaugeType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),
		},
	)
	return GaugeDef1[V0]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a GaugeDef that has all of the given tag values bound. It can be passed to
// Metrics.Gauge() to produce a metric to log data to.
func (d GaugeDef1[V0]) Values(v0 V0) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),
		}),

		ok: d.ok,
	}
}

// GaugeDef2 is the definition of a gauge metric with 2 tag(s).
type GaugeDef2[V0 TagValue, V1 TagValue] struct {
	name   string
	prefix []string
	keys   [2]string

	ok bool
}

// NewGaugeDef2 defines a gauge metric with 2 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewGaugeDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,

) GaugeDef2[V0, V1] {

	var zero0 V0

	var zero1 V1

	ok := registerDef(
		GaugeType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),
		},
	)
	return GaugeDef2[V0, V1]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a GaugeDef that has all of the given tag values bound. It can be passed to
// Metrics.Gauge() to produce a metric to log data to.
func (d GaugeDef2[V0, V1]) Values(v0 V0, v1 V1) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		}),

		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a GaugeDef1 that
// can be used to set the rest.
func (d GaugeDef2[V0, V1]) Prefix1(v0 V0) GaugeDef1[V1] {
	return GaugeDef1[V1]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[1]string)(d.keys[1:])),

		ok: d.ok,
	}
}

// GaugeDef3 is the definition of a gauge metric with 3 tag(s).
type GaugeDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name   string
	prefix []string
	keys   [3]string

	ok bool
}

// NewGaugeDef3 defines a gauge metric with 3 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewGaugeDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,

) GaugeDef3[V0, V1, V2] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	ok := registerDef(
		GaugeType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),
		},
	)
	return GaugeDef3[V0, V1, V2]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a GaugeDef that has all of the given tag values bound. It can be passed to
// Metrics.Gauge() to produce a metric to log data to.
func (d GaugeDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		}),

		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a GaugeDef2 that
// can be used to set the rest.
func (d GaugeDef3[V0, V1, V2]) Prefix1(v0 V0) GaugeDef2[V1, V2] {
	return GaugeDef2[V1, V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[2]string)(d.keys[1:])),

		ok: d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a GaugeDef1 that
// can be used to set the rest.
func (d GaugeDef3[V0, V1, V2]) Prefix2(v0 V0, v1 V1) GaugeDef1[V2] {
	return GaugeDef1[V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[1]string)(d.keys[2:])),

		ok: d.ok,
	}
}

// GaugeDef4 is the definition of a gauge metric with 4 tag(s).
type GaugeDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name   string
	prefix []string
	keys   [4]string

	ok bool
}

// NewGaugeDef4 defines a gauge metric with 4 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewGaugeDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,

) GaugeDef4[V0, V1, V2, V3] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	var zero3 V3

	ok := registerDef(
		GaugeType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),

			reflect.TypeOf(zero3),
		},
	)
	return GaugeDef4[V0, V1, V2, V3]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a GaugeDef that has all of the given tag values bound. It can be passed to
// Metrics.Gauge() to produce a metric to log data to.
func (d GaugeDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		}),

		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a GaugeDef3 that
// can be used to set the rest.
func (d GaugeDef4[V0, V1, V2, V3]) Prefix1(v0 V0) GaugeDef3[V1, V2, V3] {
	return GaugeDef3[V1, V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[3]string)(d.keys[1:])),

		ok: d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a GaugeDef2 that
// can be used to set the rest.
func (d GaugeDef4[V0, V1, V2, V3]) Prefix2(v0 V0, v1 V1) GaugeDef2[V2, V3] {
	return GaugeDef2[V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[2]string)(d.keys[2:])),

		ok: d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a GaugeDef1 that
// can be used to set the rest.
func (d GaugeDef4[V0, V1, V2, V3]) Prefix3(v0 V0, v1 V1, v2 V2) GaugeDef1[V3] {
	return GaugeDef1[V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys: *((*[1]string)(d.keys[3:])),

		ok: d.ok,
	}
}

// GaugeDef5 is the definition of a gauge metric with 5 tag(s).
type GaugeDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name   string
	prefix []string
	keys   [5]string

	ok bool
}

// NewGaugeDef5 defines a gauge metric with 5 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewGaugeDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,

) GaugeDef5[V0, V1, V2, V3, V4] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	var zero3 V3

	var zero4 V4

	ok := registerDef(
		GaugeType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),

			reflect.TypeOf(zero3),

			reflect.TypeOf(zero4),
		},
	)
	return GaugeDef5[V0, V1, V2, V3, V4]{
		name: name,
		keys: keys,

		ok: ok,
	}
}

// Values returns a GaugeDef that has all of the given tag values bound. It can be passed to
// Metrics.Gauge() to produce a metric to log data to.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		}),

		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a GaugeDef4 that
// can be used to set the rest.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Prefix1(v0 V0) GaugeDef4[V1, V2, V3, V4] {
	return GaugeDef4[V1, V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[4]string)(d.keys[1:])),

		ok: d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a GaugeDef3 that
// can be used to set the rest.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Prefix2(v0 V0, v1 V1) GaugeDef3[V2, V3, V4] {
	return GaugeDef3[V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[3]string)(d.keys[2:])),

		ok: d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a GaugeDef2 that
// can be used to set the rest.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Prefix3(v0 V0, v1 V1, v2 V2) GaugeDef2[V3, V4] {
	return GaugeDef2[V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys: *((*[2]string)(d.keys[3:])),

		ok: d.ok,
	}
}

// Prefix4 sets the value of the first 4 tags, returning a GaugeDef1 that
// can be used to set the rest.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Prefix4(v0 V0, v1 V1, v2 V2, v3 V3) GaugeDef1[V4] {
	return GaugeDef1[V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		keys: *((*[1]string)(d.keys[4:])),

		ok: d.ok,
	}
}

// DistributionDef1 is the definition of a distribution metric with 1 tag(s).
type DistributionDef1[V0 TagValue] struct {
	name       string
	prefix     []string
	keys       [1]string
	sampleRate float64
	ok         bool
}

// NewDistributionDef1 defines a distribution metric with 1 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewDistributionDef1[V0 TagValue](
	name string,
	description string,
	unit Unit,
	keys [1]string,
	sampleRate float64,
) DistributionDef1[V0] {

	var zero0 V0

	ok := registerDef(
		DistributionType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),
		},
	)
	return DistributionDef1[V0]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a DistributionDef that has all of the given tag values bound. It can be passed to
// Metrics.Distribution() to produce a metric to log data to.
func (d DistributionDef1[V0]) Values(v0 V0) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// DistributionDef2 is the definition of a distribution metric with 2 tag(s).
type DistributionDef2[V0 TagValue, V1 TagValue] struct {
	name       string
	prefix     []string
	keys       [2]string
	sampleRate float64
	ok         bool
}

// NewDistributionDef2 defines a distribution metric with 2 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewDistributionDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,
	sampleRate float64,
) DistributionDef2[V0, V1] {

	var zero0 V0

	var zero1 V1

	ok := registerDef(
		DistributionType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),
		},
	)
	return DistributionDef2[V0, V1]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a DistributionDef that has all of the given tag values bound. It can be passed to
// Metrics.Distribution() to produce a metric to log data to.
func (d DistributionDef2[V0, V1]) Values(v0 V0, v1 V1) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a DistributionDef1 that
// can be used to set the rest.
func (d DistributionDef2[V0, V1]) Prefix1(v0 V0) DistributionDef1[V1] {
	return DistributionDef1[V1]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys:       *((*[1]string)(d.keys[1:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// DistributionDef3 is the definition of a distribution metric with 3 tag(s).
type DistributionDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name       string
	prefix     []string
	keys       [3]string
	sampleRate float64
	ok         bool
}

// NewDistributionDef3 defines a distribution metric with 3 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewDistributionDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,
	sampleRate float64,
) DistributionDef3[V0, V1, V2] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	ok := registerDef(
		DistributionType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),
		},
	)
	return DistributionDef3[V0, V1, V2]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a DistributionDef that has all of the given tag values bound. It can be passed to
// Metrics.Distribution() to produce a metric to log data to.
func (d DistributionDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a DistributionDef2 that
// can be used to set the rest.
func (d DistributionDef3[V0, V1, V2]) Prefix1(v0 V0) DistributionDef2[V1, V2] {
	return DistributionDef2[V1, V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys:       *((*[2]string)(d.keys[1:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a DistributionDef1 that
// can be used to set the rest.
func (d DistributionDef3[V0, V1, V2]) Prefix2(v0 V0, v1 V1) DistributionDef1[V2] {
	return DistributionDef1[V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys:       *((*[1]string)(d.keys[2:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// DistributionDef4 is the definition of a distribution metric with 4 tag(s).
type DistributionDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name       string
	prefix     []string
	keys       [4]string
	sampleRate float64
	ok         bool
}

// NewDistributionDef4 defines a distribution metric with 4 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewDistributionDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,
	sampleRate float64,
) DistributionDef4[V0, V1, V2, V3] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	var zero3 V3

	ok := registerDef(
		DistributionType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),

			reflect.TypeOf(zero3),
		},
	)
	return DistributionDef4[V0, V1, V2, V3]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a DistributionDef that has all of the given tag values bound. It can be passed to
// Metrics.Distribution() to produce a metric to log data to.
func (d DistributionDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a DistributionDef3 that
// can be used to set the rest.
func (d DistributionDef4[V0, V1, V2, V3]) Prefix1(v0 V0) DistributionDef3[V1, V2, V3] {
	return DistributionDef3[V1, V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys:       *((*[3]string)(d.keys[1:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a DistributionDef2 that
// can be used to set the rest.
func (d DistributionDef4[V0, V1, V2, V3]) Prefix2(v0 V0, v1 V1) DistributionDef2[V2, V3] {
	return DistributionDef2[V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys:       *((*[2]string)(d.keys[2:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a DistributionDef1 that
// can be used to set the rest.
func (d DistributionDef4[V0, V1, V2, V3]) Prefix3(v0 V0, v1 V1, v2 V2) DistributionDef1[V3] {
	return DistributionDef1[V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys:       *((*[1]string)(d.keys[3:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// DistributionDef5 is the definition of a distribution metric with 5 tag(s).
type DistributionDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name       string
	prefix     []string
	keys       [5]string
	sampleRate float64
	ok         bool
}

// NewDistributionDef5 defines a distribution metric with 5 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewDistributionDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,
	sampleRate float64,
) DistributionDef5[V0, V1, V2, V3, V4] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	var zero3 V3

	var zero4 V4

	ok := registerDef(
		DistributionType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),

			reflect.TypeOf(zero3),

			reflect.TypeOf(zero4),
		},
	)
	return DistributionDef5[V0, V1, V2, V3, V4]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a DistributionDef that has all of the given tag values bound. It can be passed to
// Metrics.Distribution() to produce a metric to log data to.
func (d DistributionDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a DistributionDef4 that
// can be used to set the rest.
func (d DistributionDef5[V0, V1, V2, V3, V4]) Prefix1(v0 V0) DistributionDef4[V1, V2, V3, V4] {
	return DistributionDef4[V1, V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys:       *((*[4]string)(d.keys[1:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a DistributionDef3 that
// can be used to set the rest.
func (d DistributionDef5[V0, V1, V2, V3, V4]) Prefix2(v0 V0, v1 V1) DistributionDef3[V2, V3, V4] {
	return DistributionDef3[V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys:       *((*[3]string)(d.keys[2:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a DistributionDef2 that
// can be used to set the rest.
func (d DistributionDef5[V0, V1, V2, V3, V4]) Prefix3(v0 V0, v1 V1, v2 V2) DistributionDef2[V3, V4] {
	return DistributionDef2[V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys:       *((*[2]string)(d.keys[3:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix4 sets the value of the first 4 tags, returning a DistributionDef1 that
// can be used to set the rest.
func (d DistributionDef5[V0, V1, V2, V3, V4]) Prefix4(v0 V0, v1 V1, v2 V2, v3 V3) DistributionDef1[V4] {
	return DistributionDef1[V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		keys:       *((*[1]string)(d.keys[4:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// SetDef1 is the definition of a set metric with 1 tag(s).
type SetDef1[V0 TagValue] struct {
	name       string
	prefix     []string
	keys       [1]string
	sampleRate float64
	ok         bool
}

// NewSetDef1 defines a set metric with 1 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewSetDef1[V0 TagValue](
	name string,
	description string,
	unit Unit,
	keys [1]string,
	sampleRate float64,
) SetDef1[V0] {

	var zero0 V0

	ok := registerDef(
		SetType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),
		},
	)
	return SetDef1[V0]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a SetDef that has all of the given tag values bound. It can be passed to
// Metrics.Set() to produce a metric to log data to.
func (d SetDef1[V0]) Values(v0 V0) SetDef {
	return SetDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// SetDef2 is the definition of a set metric with 2 tag(s).
type SetDef2[V0 TagValue, V1 TagValue] struct {
	name       string
	prefix     []string
	keys       [2]string
	sampleRate float64
	ok         bool
}

// NewSetDef2 defines a set metric with 2 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewSetDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,
	sampleRate float64,
) SetDef2[V0, V1] {

	var zero0 V0

	var zero1 V1

	ok := registerDef(
		SetType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),
		},
	)
	return SetDef2[V0, V1]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a SetDef that has all of the given tag values bound. It can be passed to
// Metrics.Set() to produce a metric to log data to.
func (d SetDef2[V0, V1]) Values(v0 V0, v1 V1) SetDef {
	return SetDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a SetDef1 that
// can be used to set the rest.
func (d SetDef2[V0, V1]) Prefix1(v0 V0) SetDef1[V1] {
	return SetDef1[V1]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys:       *((*[1]string)(d.keys[1:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// SetDef3 is the definition of a set metric with 3 tag(s).
type SetDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name       string
	prefix     []string
	keys       [3]string
	sampleRate float64
	ok         bool
}

// NewSetDef3 defines a set metric with 3 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewSetDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,
	sampleRate float64,
) SetDef3[V0, V1, V2] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	ok := registerDef(
		SetType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),
		},
	)
	return SetDef3[V0, V1, V2]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a SetDef that has all of the given tag values bound. It can be passed to
// Metrics.Set() to produce a metric to log data to.
func (d SetDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) SetDef {
	return SetDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a SetDef2 that
// can be used to set the rest.
func (d SetDef3[V0, V1, V2]) Prefix1(v0 V0) SetDef2[V1, V2] {
	return SetDef2[V1, V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys:       *((*[2]string)(d.keys[1:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a SetDef1 that
// can be used to set the rest.
func (d SetDef3[V0, V1, V2]) Prefix2(v0 V0, v1 V1) SetDef1[V2] {
	return SetDef1[V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys:       *((*[1]string)(d.keys[2:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// SetDef4 is the definition of a set metric with 4 tag(s).
type SetDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name       string
	prefix     []string
	keys       [4]string
	sampleRate float64
	ok         bool
}

// NewSetDef4 defines a set metric with 4 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewSetDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,
	sampleRate float64,
) SetDef4[V0, V1, V2, V3] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	var zero3 V3

	ok := registerDef(
		SetType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),

			reflect.TypeOf(zero3),
		},
	)
	return SetDef4[V0, V1, V2, V3]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a SetDef that has all of the given tag values bound. It can be passed to
// Metrics.Set() to produce a metric to log data to.
func (d SetDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) SetDef {
	return SetDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a SetDef3 that
// can be used to set the rest.
func (d SetDef4[V0, V1, V2, V3]) Prefix1(v0 V0) SetDef3[V1, V2, V3] {
	return SetDef3[V1, V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys:       *((*[3]string)(d.keys[1:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a SetDef2 that
// can be used to set the rest.
func (d SetDef4[V0, V1, V2, V3]) Prefix2(v0 V0, v1 V1) SetDef2[V2, V3] {
	return SetDef2[V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys:       *((*[2]string)(d.keys[2:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a SetDef1 that
// can be used to set the rest.
func (d SetDef4[V0, V1, V2, V3]) Prefix3(v0 V0, v1 V1, v2 V2) SetDef1[V3] {
	return SetDef1[V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys:       *((*[1]string)(d.keys[3:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// SetDef5 is the definition of a set metric with 5 tag(s).
type SetDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name       string
	prefix     []string
	keys       [5]string
	sampleRate float64
	ok         bool
}

// NewSetDef5 defines a set metric with 5 tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func NewSetDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,
	sampleRate float64,
) SetDef5[V0, V1, V2, V3, V4] {

	var zero0 V0

	var zero1 V1

	var zero2 V2

	var zero3 V3

	var zero4 V4

	ok := registerDef(
		SetType,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{

			reflect.TypeOf(zero0),

			reflect.TypeOf(zero1),

			reflect.TypeOf(zero2),

			reflect.TypeOf(zero3),

			reflect.TypeOf(zero4),
		},
	)
	return SetDef5[V0, V1, V2, V3, V4]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

// Values returns a SetDef that has all of the given tag values bound. It can be passed to
// Metrics.Set() to produce a metric to log data to.
func (d SetDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) SetDef {
	return SetDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		}),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a SetDef4 that
// can be used to set the rest.
func (d SetDef5[V0, V1, V2, V3, V4]) Prefix1(v0 V0) SetDef4[V1, V2, V3, V4] {
	return SetDef4[V1, V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys:       *((*[4]string)(d.keys[1:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a SetDef3 that
// can be used to set the rest.
func (d SetDef5[V0, V1, V2, V3, V4]) Prefix2(v0 V0, v1 V1) SetDef3[V2, V3, V4] {
	return SetDef3[V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys:       *((*[3]string)(d.keys[2:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a SetDef2 that
// can be used to set the rest.
func (d SetDef5[V0, V1, V2, V3, V4]) Prefix3(v0 V0, v1 V1, v2 V2) SetDef2[V3, V4] {
	return SetDef2[V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys:       *((*[2]string)(d.keys[3:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

// Prefix4 sets the value of the first 4 tags, returning a SetDef1 that
// can be used to set the rest.
func (d SetDef5[V0, V1, V2, V3, V4]) Prefix4(v0 V0, v1 V1, v2 V2, v3 V3) SetDef1[V4] {
	return SetDef1[V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		keys:       *((*[1]string)(d.keys[4:])),
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}
