package metrics

// generated by `go run ./gen_defs > defs_generated.go && gofmt -w defs_generated.go`

type CounterDef2[V0 TagValue, V1 TagValue] struct {
	name   string
	prefix []string
	keys   [2]string
	ok     bool
}

func NewCounterDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,
) CounterDef2[V0, V1] {
	ok := registerDef(counterType, name, unit, description)
	return CounterDef2[V0, V1]{
		name: name,
		keys: keys,
		ok:   ok,
	}
}

func (d CounterDef2[V0, V1]) Values(v0 V0, v1 V1) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		}),
		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a CounterDef1 that
// can be used to set the rest.
func (d CounterDef2[V0, V1]) Prefix1(v0 V0) CounterDef1[V1] {
	return CounterDef1[V1]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[1]string)(d.keys[1:])),
		ok:   d.ok,
	}
}

type CounterDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name   string
	prefix []string
	keys   [3]string
	ok     bool
}

func NewCounterDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,
) CounterDef3[V0, V1, V2] {
	ok := registerDef(counterType, name, unit, description)
	return CounterDef3[V0, V1, V2]{
		name: name,
		keys: keys,
		ok:   ok,
	}
}

func (d CounterDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		}),
		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a CounterDef2 that
// can be used to set the rest.
func (d CounterDef3[V0, V1, V2]) Prefix1(v0 V0) CounterDef2[V1, V2] {
	return CounterDef2[V1, V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[2]string)(d.keys[1:])),
		ok:   d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a CounterDef1 that
// can be used to set the rest.
func (d CounterDef3[V0, V1, V2]) Prefix2(v0 V0, v1 V1) CounterDef1[V2] {
	return CounterDef1[V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[1]string)(d.keys[2:])),
		ok:   d.ok,
	}
}

type CounterDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name   string
	prefix []string
	keys   [4]string
	ok     bool
}

func NewCounterDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,
) CounterDef4[V0, V1, V2, V3] {
	ok := registerDef(counterType, name, unit, description)
	return CounterDef4[V0, V1, V2, V3]{
		name: name,
		keys: keys,
		ok:   ok,
	}
}

func (d CounterDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		}),
		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a CounterDef3 that
// can be used to set the rest.
func (d CounterDef4[V0, V1, V2, V3]) Prefix1(v0 V0) CounterDef3[V1, V2, V3] {
	return CounterDef3[V1, V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[3]string)(d.keys[1:])),
		ok:   d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a CounterDef2 that
// can be used to set the rest.
func (d CounterDef4[V0, V1, V2, V3]) Prefix2(v0 V0, v1 V1) CounterDef2[V2, V3] {
	return CounterDef2[V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[2]string)(d.keys[2:])),
		ok:   d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a CounterDef1 that
// can be used to set the rest.
func (d CounterDef4[V0, V1, V2, V3]) Prefix3(v0 V0, v1 V1, v2 V2) CounterDef1[V3] {
	return CounterDef1[V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys: *((*[1]string)(d.keys[3:])),
		ok:   d.ok,
	}
}

type CounterDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name   string
	prefix []string
	keys   [5]string
	ok     bool
}

func NewCounterDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,
) CounterDef5[V0, V1, V2, V3, V4] {
	ok := registerDef(counterType, name, unit, description)
	return CounterDef5[V0, V1, V2, V3, V4]{
		name: name,
		keys: keys,
		ok:   ok,
	}
}

func (d CounterDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) CounterDef {
	return CounterDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		}),
		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a CounterDef4 that
// can be used to set the rest.
func (d CounterDef5[V0, V1, V2, V3, V4]) Prefix1(v0 V0) CounterDef4[V1, V2, V3, V4] {
	return CounterDef4[V1, V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[4]string)(d.keys[1:])),
		ok:   d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a CounterDef3 that
// can be used to set the rest.
func (d CounterDef5[V0, V1, V2, V3, V4]) Prefix2(v0 V0, v1 V1) CounterDef3[V2, V3, V4] {
	return CounterDef3[V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[3]string)(d.keys[2:])),
		ok:   d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a CounterDef2 that
// can be used to set the rest.
func (d CounterDef5[V0, V1, V2, V3, V4]) Prefix3(v0 V0, v1 V1, v2 V2) CounterDef2[V3, V4] {
	return CounterDef2[V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys: *((*[2]string)(d.keys[3:])),
		ok:   d.ok,
	}
}

// Prefix4 sets the value of the first 4 tags, returning a CounterDef1 that
// can be used to set the rest.
func (d CounterDef5[V0, V1, V2, V3, V4]) Prefix4(v0 V0, v1 V1, v2 V2, v3 V3) CounterDef1[V4] {
	return CounterDef1[V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		keys: *((*[1]string)(d.keys[4:])),
		ok:   d.ok,
	}
}

type GaugeDef2[V0 TagValue, V1 TagValue] struct {
	name   string
	prefix []string
	keys   [2]string
	ok     bool
}

func NewGaugeDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,
) GaugeDef2[V0, V1] {
	ok := registerDef(gaugeType, name, unit, description)
	return GaugeDef2[V0, V1]{
		name: name,
		keys: keys,
		ok:   ok,
	}
}

func (d GaugeDef2[V0, V1]) Values(v0 V0, v1 V1) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		}),
		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a GaugeDef1 that
// can be used to set the rest.
func (d GaugeDef2[V0, V1]) Prefix1(v0 V0) GaugeDef1[V1] {
	return GaugeDef1[V1]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[1]string)(d.keys[1:])),
		ok:   d.ok,
	}
}

type GaugeDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name   string
	prefix []string
	keys   [3]string
	ok     bool
}

func NewGaugeDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,
) GaugeDef3[V0, V1, V2] {
	ok := registerDef(gaugeType, name, unit, description)
	return GaugeDef3[V0, V1, V2]{
		name: name,
		keys: keys,
		ok:   ok,
	}
}

func (d GaugeDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		}),
		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a GaugeDef2 that
// can be used to set the rest.
func (d GaugeDef3[V0, V1, V2]) Prefix1(v0 V0) GaugeDef2[V1, V2] {
	return GaugeDef2[V1, V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[2]string)(d.keys[1:])),
		ok:   d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a GaugeDef1 that
// can be used to set the rest.
func (d GaugeDef3[V0, V1, V2]) Prefix2(v0 V0, v1 V1) GaugeDef1[V2] {
	return GaugeDef1[V2]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[1]string)(d.keys[2:])),
		ok:   d.ok,
	}
}

type GaugeDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name   string
	prefix []string
	keys   [4]string
	ok     bool
}

func NewGaugeDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,
) GaugeDef4[V0, V1, V2, V3] {
	ok := registerDef(gaugeType, name, unit, description)
	return GaugeDef4[V0, V1, V2, V3]{
		name: name,
		keys: keys,
		ok:   ok,
	}
}

func (d GaugeDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		}),
		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a GaugeDef3 that
// can be used to set the rest.
func (d GaugeDef4[V0, V1, V2, V3]) Prefix1(v0 V0) GaugeDef3[V1, V2, V3] {
	return GaugeDef3[V1, V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[3]string)(d.keys[1:])),
		ok:   d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a GaugeDef2 that
// can be used to set the rest.
func (d GaugeDef4[V0, V1, V2, V3]) Prefix2(v0 V0, v1 V1) GaugeDef2[V2, V3] {
	return GaugeDef2[V2, V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[2]string)(d.keys[2:])),
		ok:   d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a GaugeDef1 that
// can be used to set the rest.
func (d GaugeDef4[V0, V1, V2, V3]) Prefix3(v0 V0, v1 V1, v2 V2) GaugeDef1[V3] {
	return GaugeDef1[V3]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys: *((*[1]string)(d.keys[3:])),
		ok:   d.ok,
	}
}

type GaugeDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name   string
	prefix []string
	keys   [5]string
	ok     bool
}

func NewGaugeDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,
) GaugeDef5[V0, V1, V2, V3, V4] {
	ok := registerDef(gaugeType, name, unit, description)
	return GaugeDef5[V0, V1, V2, V3, V4]{
		name: name,
		keys: keys,
		ok:   ok,
	}
}

func (d GaugeDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) GaugeDef {
	return GaugeDef{
		name: d.name,
		tags: joinStrings(d.prefix, []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		}),
		ok: d.ok,
	}
}

// Prefix1 sets the value of the first 1 tags, returning a GaugeDef4 that
// can be used to set the rest.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Prefix1(v0 V0) GaugeDef4[V1, V2, V3, V4] {
	return GaugeDef4[V1, V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),
		},
		keys: *((*[4]string)(d.keys[1:])),
		ok:   d.ok,
	}
}

// Prefix2 sets the value of the first 2 tags, returning a GaugeDef3 that
// can be used to set the rest.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Prefix2(v0 V0, v1 V1) GaugeDef3[V2, V3, V4] {
	return GaugeDef3[V2, V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		keys: *((*[3]string)(d.keys[2:])),
		ok:   d.ok,
	}
}

// Prefix3 sets the value of the first 3 tags, returning a GaugeDef2 that
// can be used to set the rest.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Prefix3(v0 V0, v1 V1, v2 V2) GaugeDef2[V3, V4] {
	return GaugeDef2[V3, V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		keys: *((*[2]string)(d.keys[3:])),
		ok:   d.ok,
	}
}

// Prefix4 sets the value of the first 4 tags, returning a GaugeDef1 that
// can be used to set the rest.
func (d GaugeDef5[V0, V1, V2, V3, V4]) Prefix4(v0 V0, v1 V1, v2 V2, v3 V3) GaugeDef1[V4] {
	return GaugeDef1[V4]{
		name: d.name,
		prefix: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		keys: *((*[1]string)(d.keys[4:])),
		ok:   d.ok,
	}
}

type HistogramDef2[V0 TagValue, V1 TagValue] struct {
	name       string
	keys       [2]string
	sampleRate float64
	ok         bool
}

func NewHistogramDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,
	sampleRate float64,
) HistogramDef2[V0, V1] {
	ok := registerDef(histogramType, name, unit, description)
	return HistogramDef2[V0, V1]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d HistogramDef2[V0, V1]) Values(v0 V0, v1 V1) HistogramDef {
	return HistogramDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type HistogramDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name       string
	keys       [3]string
	sampleRate float64
	ok         bool
}

func NewHistogramDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,
	sampleRate float64,
) HistogramDef3[V0, V1, V2] {
	ok := registerDef(histogramType, name, unit, description)
	return HistogramDef3[V0, V1, V2]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d HistogramDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) HistogramDef {
	return HistogramDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type HistogramDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name       string
	keys       [4]string
	sampleRate float64
	ok         bool
}

func NewHistogramDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,
	sampleRate float64,
) HistogramDef4[V0, V1, V2, V3] {
	ok := registerDef(histogramType, name, unit, description)
	return HistogramDef4[V0, V1, V2, V3]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d HistogramDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) HistogramDef {
	return HistogramDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type HistogramDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name       string
	keys       [5]string
	sampleRate float64
	ok         bool
}

func NewHistogramDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,
	sampleRate float64,
) HistogramDef5[V0, V1, V2, V3, V4] {
	ok := registerDef(histogramType, name, unit, description)
	return HistogramDef5[V0, V1, V2, V3, V4]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d HistogramDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) HistogramDef {
	return HistogramDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type DistributionDef2[V0 TagValue, V1 TagValue] struct {
	name       string
	keys       [2]string
	sampleRate float64
	ok         bool
}

func NewDistributionDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,
	sampleRate float64,
) DistributionDef2[V0, V1] {
	ok := registerDef(distributionType, name, unit, description)
	return DistributionDef2[V0, V1]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d DistributionDef2[V0, V1]) Values(v0 V0, v1 V1) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type DistributionDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name       string
	keys       [3]string
	sampleRate float64
	ok         bool
}

func NewDistributionDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,
	sampleRate float64,
) DistributionDef3[V0, V1, V2] {
	ok := registerDef(distributionType, name, unit, description)
	return DistributionDef3[V0, V1, V2]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d DistributionDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type DistributionDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name       string
	keys       [4]string
	sampleRate float64
	ok         bool
}

func NewDistributionDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,
	sampleRate float64,
) DistributionDef4[V0, V1, V2, V3] {
	ok := registerDef(distributionType, name, unit, description)
	return DistributionDef4[V0, V1, V2, V3]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d DistributionDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type DistributionDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name       string
	keys       [5]string
	sampleRate float64
	ok         bool
}

func NewDistributionDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,
	sampleRate float64,
) DistributionDef5[V0, V1, V2, V3, V4] {
	ok := registerDef(distributionType, name, unit, description)
	return DistributionDef5[V0, V1, V2, V3, V4]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d DistributionDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) DistributionDef {
	return DistributionDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type SetDef2[V0 TagValue, V1 TagValue] struct {
	name       string
	keys       [2]string
	sampleRate float64
	ok         bool
}

func NewSetDef2[V0 TagValue, V1 TagValue](
	name string,
	description string,
	unit Unit,
	keys [2]string,
	sampleRate float64,
) SetDef2[V0, V1] {
	ok := registerDef(setType, name, unit, description)
	return SetDef2[V0, V1]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d SetDef2[V0, V1]) Values(v0 V0, v1 V1) SetDef {
	return SetDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type SetDef3[V0 TagValue, V1 TagValue, V2 TagValue] struct {
	name       string
	keys       [3]string
	sampleRate float64
	ok         bool
}

func NewSetDef3[V0 TagValue, V1 TagValue, V2 TagValue](
	name string,
	description string,
	unit Unit,
	keys [3]string,
	sampleRate float64,
) SetDef3[V0, V1, V2] {
	ok := registerDef(setType, name, unit, description)
	return SetDef3[V0, V1, V2]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d SetDef3[V0, V1, V2]) Values(v0 V0, v1 V1, v2 V2) SetDef {
	return SetDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type SetDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue] struct {
	name       string
	keys       [4]string
	sampleRate float64
	ok         bool
}

func NewSetDef4[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue](
	name string,
	description string,
	unit Unit,
	keys [4]string,
	sampleRate float64,
) SetDef4[V0, V1, V2, V3] {
	ok := registerDef(setType, name, unit, description)
	return SetDef4[V0, V1, V2, V3]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d SetDef4[V0, V1, V2, V3]) Values(v0 V0, v1 V1, v2 V2, v3 V3) SetDef {
	return SetDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}

type SetDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue] struct {
	name       string
	keys       [5]string
	sampleRate float64
	ok         bool
}

func NewSetDef5[V0 TagValue, V1 TagValue, V2 TagValue, V3 TagValue, V4 TagValue](
	name string,
	description string,
	unit Unit,
	keys [5]string,
	sampleRate float64,
) SetDef5[V0, V1, V2, V3, V4] {
	ok := registerDef(setType, name, unit, description)
	return SetDef5[V0, V1, V2, V3, V4]{
		name:       name,
		keys:       keys,
		sampleRate: sampleRate,
		ok:         ok,
	}
}

func (d SetDef5[V0, V1, V2, V3, V4]) Values(v0 V0, v1 V1, v2 V2, v3 V3, v4 V4) SetDef {
	return SetDef{
		name: d.name,
		tags: []string{

			makeTag(d.keys[0], tagValueString(v0)),

			makeTag(d.keys[1], tagValueString(v1)),

			makeTag(d.keys[2], tagValueString(v2)),

			makeTag(d.keys[3], tagValueString(v3)),

			makeTag(d.keys[4], tagValueString(v4)),
		},
		sampleRate: d.sampleRate,
		ok:         d.ok,
	}
}
