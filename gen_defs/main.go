package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

func main() {
	fmt.Println("package metrics")
	fmt.Println()
	fmt.Println("import \"reflect\"")
	fmt.Println()
	fmt.Println("// generated by `go run ./gen_defs > defs_generated.go && gofmt -w defs_generated.go`")
	fmt.Println()

	type vars struct {
		N           int
		Ns          []int
		Metric      string
		MetricLower string
		SampleRate  bool
	}

	n := 6
	ns := make([]int, n)
	for j := range ns {
		ns[j] = j
	}

	type metricOpts struct {
		Name       string
		SampleRate bool
	}

	for _, metric := range []metricOpts{
		{Name: "Counter", SampleRate: false},
		{Name: "Gauge", SampleRate: false},
		{Name: "Distribution", SampleRate: true},
		{Name: "Set", SampleRate: true},
	} {
		for i := 1; i < n; i++ {
			metricTmpl.Execute(os.Stdout, vars{
				N:           i,
				Ns:          ns[:i],
				Metric:      metric.Name,
				MetricLower: strings.ToLower(metric.Name),
				SampleRate:  metric.SampleRate,
			})

			for k := 1; k <= i-1; k++ {
				bindPrefixTmpl.Execute(os.Stdout, struct {
					N          int
					Ns         []int
					K          int
					Ks         []int
					NMinusK    int
					NMinusKs   []int
					Metric     string
					SampleRate bool
				}{
					N:          i,
					Ns:         ns[:i],
					K:          k,
					Ks:         ns[:k],
					NMinusK:    i - k,
					NMinusKs:   ns[k:i],
					Metric:     metric.Name,
					SampleRate: metric.SampleRate,
				})
			}
		}
	}
}

var metricTmpl = template.Must(template.New("name").Parse(`
// {{.Metric}}Def{{.N}} is the definition of a {{.MetricLower}} metric with {{.N}} tag(s).
type {{.Metric}}Def{{.N}}[{{range .Ns}} V{{.}} TagValue, {{end}}] struct {
	name       string
	prefix     []string
	keys       [{{.N}}]string
	{{if .SampleRate}} sampleRate float64 {{end}}
	ok         bool
}

// New{{.Metric}}Def{{.N}} defines a {{.MetricLower}} metric with {{.N}} tag(s).
//
// It must be called from a top-level var block in a file called metrics.go, otherwise it will panic
// (if main() has not yet started) or return an inert def that will not produce any data.
func New{{.Metric}}Def{{.N}}[{{range .Ns}} V{{.}} TagValue, {{end}}](
	name string,
	description string,
	unit Unit,
	keys [{{.N}}]string,
	{{if .SampleRate}} sampleRate float64, {{end}}
) {{.Metric}}Def{{.N}}[{{range .Ns}} V{{.}}, {{end}}] {
	{{range .Ns}}
	var zero{{.}} V{{.}}
	{{ end }}
	ok := registerDef(
		{{.Metric}}Type,
		name,
		description,
		unit,
		keys[:],
		[]reflect.Type{
			{{range .Ns}}
			reflect.TypeOf(zero{{.}}),
			{{ end }}
		},
	)
	return {{.Metric}}Def{{.N}}[{{range .Ns}} V{{.}}, {{end}}]{
		name:       name,
		keys:       keys,
		{{if .SampleRate}}sampleRate: sampleRate,{{end}}
		ok:         ok,
	}
}

// Values returns a {{.Metric}}Def that has all of the given tag values bound. It can be passed to
// Metrics.{{.Metric}}() to produce a metric to log data to.
func (d {{.Metric}}Def{{.N}}[{{range .Ns}} V{{.}}, {{end}}]) Values({{range .Ns}} v{{.}} V{{.}}, {{end}}) {{.Metric}}Def {
	return {{.Metric}}Def{
		name: d.name,
		tags: joinStrings(d.prefix, []string{
			{{range .Ns}}
			makeTag(d.keys[{{.}}], tagValueString(v{{.}})),
			{{ end }}
		}),
		{{if .SampleRate}}sampleRate: d.sampleRate,{{end}}
		ok: d.ok,
	}
}
`))

var bindPrefixTmpl = template.Must(template.New("name").Parse(`
// Prefix{{.K}} sets the value of the first {{.K}} tags, returning a {{.Metric}}Def{{.NMinusK}} that
// can be used to set the rest.
func (d {{.Metric}}Def{{.N}}[{{range .Ns}} V{{.}}, {{end}}]) Prefix{{.K}}({{range .Ks}} v{{.}} V{{.}}, {{end}}) {{.Metric}}Def{{.NMinusK}}[{{range .NMinusKs}} V{{.}}, {{end}}] {
	return {{.Metric}}Def{{.NMinusK}}[{{range .NMinusKs}} V{{.}}, {{end}}]{
		name: d.name,
		prefix: []string{
			{{range .Ks}}
			makeTag(d.keys[{{.}}], tagValueString(v{{.}})),
			{{ end }}
		},
		keys: *((*[{{.NMinusK}}]string)(d.keys[{{.K}}:])),
		{{if .SampleRate}}sampleRate: d.sampleRate,{{end}}
		ok:   d.ok,
	}
}
`))
